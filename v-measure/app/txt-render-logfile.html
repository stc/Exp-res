<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>V-COLLISION-TXT</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.7.0/lib/p5.min.js"></script>
  <script src="https://unpkg.com/p5.js-svg@1.6.0"></script>
</head>

<body style="margin:100px; background-color:black;">
  <script>
    let events = [];
    let asciiChars = ['_', '/', '-', ':', '=', '+', '*', '#', '%', '@'];
    let gridCols = 200;
    let gridRows = 200;
    let cellSize = 8;
    let grid = [];
    let mFont;
    let timestampsByRow = {};
    let eventCountsByRow = {};

    const labelColors = {
      "ARC-00": [255, 255, 255],
      "ARC-01": [255, 255, 255],
      "ARC-02": [255, 255, 255],
      "ARC-03": [255, 255, 255],
      "ARC-04": [255, 255, 255]
    };

    function preload() {
      mFont = loadFont("IBMPlexMono-Medium.ttf");
      events = loadStrings('../exports/collision_local03.txt');
    }

    function setup() {
      createCanvas((gridCols + 200) * cellSize / 1.7, gridRows * cellSize, SVG);
      textFont(mFont, cellSize);
      noLoop();

      // Define interval size for summing collisions
      let intervalSize = 1; // e.g., sum collisions every 5 lines

      // Initialize grid
      for (let y = 0; y < gridRows; y++) {
        grid[y] = [];
        for (let x = 0; x < gridCols; x++) {
          grid[y][x] = { char: random([asciiChars[floor(random([0, 0, 0, 0, 0, 1, 2]))], Number(y.toString()[0])]), label: null, type: null };
        }
      }

      // Group events by timestamp
      let groupedEvents = {};
      let minX = Infinity, maxX = -Infinity;

      for (let line of events) {
        let match = line.match(/\[([^\]]+)\].*T=([\d.]+)/);
        if (!match) continue;

        let name = match[1].split("_")[0];
        let timestamp = parseFloat(match[2]).toFixed(2);

        let coordsMatch = line.match(/X=([\d,-]+).*Z=([\d,-]+)/);
        if (!coordsMatch) continue;
        let xVal = parseFloat(coordsMatch[1].replace(',', '.'));
        let zVal = parseFloat(coordsMatch[2].replace(',', '.')).toFixed(2);

        minX = Math.min(minX, xVal);
        maxX = Math.max(maxX, xVal);

        if (!groupedEvents[timestamp]) groupedEvents[timestamp] = [];
        groupedEvents[timestamp].push({ name, xVal, zVal });
      }

      // Place grouped events in rows and sum collisions per interval
      let rowIndex = 0;
      let intervalCounter = 0;
      let intervalSum = 0;

      for (let ts in groupedEvents) {
        if (rowIndex >= gridRows) break;

        let eventsRow = groupedEvents[ts];
        intervalSum += eventsRow.length; // sum collisions

        let firstEventX = eventsRow[0].xVal;
        let startCol = Math.floor(map(firstEventX, minX, maxX, 0, gridCols - 1)) - floor(rowIndex / 1);
        startCol = constrain(startCol, 0, gridCols - 1);
        let colIndex = startCol;

        for (let ev of eventsRow) {
          let name = ev.name;
          let zStr = " " + ev.zVal.toString();

          let labelKeys = Object.keys(labelColors);
          let label = labelKeys[floor(random(labelKeys.length))];

          for (let i = 0; i < name.length; i++) {
            if (colIndex < gridCols) grid[rowIndex][colIndex++] = { char: name[i], label: label, type: "name" };
          }

          for (let i = 0; i < zStr.length; i++) {
            if (colIndex < gridCols) grid[rowIndex][colIndex++] = { char: zStr[i], label: null, type: "z" };
          }

          if (colIndex < gridCols) grid[rowIndex][colIndex++] = { char: ' ', label: null, type: null };
        }

        if (!timestampsByRow[rowIndex]) timestampsByRow[rowIndex] = [];
        timestampsByRow[rowIndex].push(ts);

        intervalCounter++;
        if (intervalCounter === intervalSize) {
          // Store the sum in the row corresponding to the interval
          eventCountsByRow[rowIndex] = intervalSum;
          intervalCounter = 0;
          intervalSum = 0;
        } else {
          eventCountsByRow[rowIndex] = intervalSum; // show cumulative so far in the interval
        }

        rowIndex++;
      }
    }

    function draw() {
      background(0);

      // Draw grid
      for (let y = 0; y < gridRows; y++) {
        for (let x = 0; x < gridCols; x++) {
          let cell = grid[y][x];
          let char = cell.char;
          let label = cell.label;
          let type = cell.type;

          //if (type === "z") fill(255, 105, 180);
          if(type === "z") fill(0,100,255)
          else if (label && labelColors[label]) fill(...labelColors[label]);
          else fill(100);

          noStroke();
          text(char, x * cellSize / 1.7, y * cellSize + cellSize);
        }
      }

      // Draw timestamps and collision sums
      let baseX = gridCols * cellSize / 1.7 + 5;
      let maxColumnWidth = 150;

      for (let row in timestampsByRow) {
        let tsArray = timestampsByRow[row];
        let colIndex = 0;
        let xOffset = baseX;
        let yPos = row * cellSize + cellSize;

        for (let ts of tsArray) {
          // pad time with zeros
          let paddedTime = ts//nf(parseFloat(ts), 3, 1);
          let tsText = `[${paddedTime}]`;
          let tsWidth = textWidth(tsText) + 10;

          if (xOffset + tsWidth - baseX > maxColumnWidth) {
            colIndex++;
            xOffset = baseX + colIndex * maxColumnWidth;
          }
          fill(255);
          if (row == 0) text("TIME(s)", xOffset, yPos);
          else text(tsText, xOffset, yPos);
          xOffset += tsWidth;
        }

        fill(200)
        if (eventCountsByRow[row] !== undefined) {
          if (row == 0) {
            text("COLLISIONS", xOffset, yPos);
          } else {
            text(`+ ${nf(eventCountsByRow[row], 5)}`, xOffset + 10, yPos);

          }
        }
      }
    }

    function keyPressed() {
      if (key == "s") save("collisions.svg");
    }
  </script>
</body>

</html>