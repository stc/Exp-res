<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>V-COLLISION-TXT</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.7.0/lib/p5.min.js"></script>
  <script src="https://unpkg.com/p5.js-svg@1.6.0"></script>
</head>

<body style="margin:100px; background-color:black;">
  <script>
    let events = [];
    let asciiChars = ['_', '/', '-', ':', '=', '+', '*', '#', '%', '@'];
    let shades = ['░', '▒', '▓', '█']
    let gridCols = 220;
    let gridRows = 320;
    let cellSize = 8;
    let grid = [];
    let mFont;
    let timestampsByRow = {};
    let eventCountsByRow = {};

    const labelColors = {
      "ARC1": [255, 255, 255],
      "ARC2": [255, 255, 255],
      "ARC3": [255, 255, 255],
      "ARC4": [255, 255, 255]
    };

    function preload() {
      mFont = loadFont("IBMPlexMono-Medium.ttf");
      events = loadStrings('../exports/collision_local04.txt');
    }

    function setup() {
      createCanvas((gridCols + 200) * cellSize / 1.7, gridRows * cellSize, SVG);
      textFont(mFont, cellSize);
      noLoop();

      // Jump every nth line
      let n = 8;
      events = events.filter((_, index) => index % n === 0);

      // Initialize grid
      for (let y = 0; y < gridRows; y++) {
        grid[y] = [];
        for (let x = 0; x < gridCols; x++) {
          //grid[y][x] = { char: random([asciiChars[floor(random([0, 0, 0, 0, 0, 1, 2]))], Number(y.toString()[0])]), label: null, type: null };
          //grid[y][x] = { char: asciiChars[floor(random([0, 0, 0, 0, 0, 1, 2]))], label: null, type: null };
          //grid[y][x] = { char: random([asciiChars[floor(random([0, 0, 0, 0, 0, 1, 2]))], shades[y%4]]), label: null, type: null };
          grid[y][x] = { char: y, label: null, type: null };
        }
      }

      // Group events by timestamp
      let groupedEvents = {};
      let minX = Infinity, maxX = -Infinity;

      for (let line of events) {
        let match = line.match(/\[([^\]]+)\].*T=([\d.]+)/);
        if (!match) continue;

        let name = match[1].split("_")[0];
        let timestamp = parseFloat(match[2]).toFixed(2);

        let coordsMatch = line.match(/X=([\d,-]+).*Y=([\d,-]+).*Z=([\d,-]+)/);
        if (!coordsMatch) continue;
        let xVal = parseFloat(coordsMatch[1].replace(',', '.'));
        let yVal = parseFloat(coordsMatch[2].replace(',', '.'));
        let zVal = parseFloat(coordsMatch[3].replace(',', '.')).toFixed(2);

        minX = Math.min(minX, xVal);
        maxX = Math.max(maxX, xVal);

        if (!groupedEvents[timestamp]) groupedEvents[timestamp] = [];
        groupedEvents[timestamp].push({ name, xVal, yVal, zVal });
      }

      // Place grouped events in rows
      let rowIndex = 0;
      for (let ts in groupedEvents) {
        if (rowIndex >= gridRows) break;

        let eventsRow = groupedEvents[ts];
        
        let firstEventX = eventsRow[0].xVal;
        let startCol = Math.floor(map(firstEventX, minX, maxX, 0, gridCols - 1))// - floor(rowIndex * map(rowIndex,0,gridRows,1,0.01));
        startCol = constrain(startCol, 0, gridCols - 1);
        let colIndex = startCol;

        // Store number of events per row
        eventCountsByRow[rowIndex] = eventsRow.length;

        let evIndex = 0
        for (let ev of eventsRow) {
          let name = ev.name;
          let coordsStr = ` X: ${ev.xVal}, Y: ${ev.yVal}, Z: ${ev.zVal}`;

          let labelKeys = Object.keys(labelColors);
          let label = labelKeys[floor(random(labelKeys.length))];

          // Place name characters
          for (let i = 0; i < name.length; i++) {
            if (colIndex < gridCols) grid[rowIndex][colIndex++] = { char: name[i], label: label, type: "name" };
          }

          // Place coordinates after name
          for (let i = 0; i < coordsStr.length; i++) {
            if (colIndex < gridCols) grid[rowIndex][colIndex++] = { char: coordsStr[i], label: null, type: "coords" };
          }

          if (colIndex < gridCols) grid[rowIndex][colIndex++] = { char: ' ', label: null, type: null };
        }

        if (!timestampsByRow[rowIndex]) timestampsByRow[rowIndex] = [];
        timestampsByRow[rowIndex].push(ts);

        rowIndex++;
      }
    }

    function draw() {
      background(0);

      // Draw grid
      let oStr = "OBJECT "
      let pStr = "POSITIONS"
      for (let y = 0; y < gridRows; y++) {
        for (let x = 0; x < gridCols; x++) {
          let cell = grid[y][x];
          let char = cell.char;
          let label = cell.label;
          let type = cell.type;

          //if(type === "coords") fill(255, 105, 180); // coordinates in pink
          if (type === "coords") fill(0,255,0); // coordinates in pink
          else if (label && labelColors[label]) fill(...labelColors[label]);
          else fill(77,20,100);

          noStroke();
          if(y>0) {
            text(char, x * cellSize / 1.7, y * cellSize + cellSize);
          }  else {
            if(x<7) {
              fill(100)
              text("0",x * cellSize / 1.7,y * cellSize + cellSize )
              fill(255)
              text(oStr[x%9], x * cellSize / 1.7 + (cellSize*gridCols/4)+cellSize*4, y * cellSize + cellSize);
            } else if(x>8&&x<18){
              fill(100)
              text("0",x * cellSize / 1.7,y * cellSize + cellSize )
              fill(0,255,0)
              text(pStr[x%9], x * cellSize / 1.7 + (cellSize*gridCols/4)+cellSize*3, y * cellSize + cellSize);
            } else {
              fill(100)
              if(x>gridCols/2+6 || x <gridCols/2-10)text("0",x * cellSize / 1.7,y * cellSize + cellSize )
            }
          }
          
        }
      }

      // Draw timestamps and collision counts
      let baseX = gridCols * cellSize / 1.7 + 5;
      let maxColumnWidth = 150;

      for (let row in timestampsByRow) {
        let tsArray = timestampsByRow[row];
        let colIndex = 0;
        let xOffset = baseX;
        let yPos = row * cellSize + cellSize;

        for (let ts of tsArray) {
          let paddedTime = nf(parseFloat(ts), 5, 1);
          let tsText = `[${paddedTime}]`;
          let tsWidth = textWidth(tsText) + 10;

          if (xOffset + tsWidth - baseX > maxColumnWidth) {
            colIndex++;
            xOffset = baseX + colIndex * maxColumnWidth;
          }
          fill(255);
          if (row == 0) text("TIME(s)", xOffset, yPos);
          else text(tsText, xOffset, yPos);
          xOffset += tsWidth;
        }

        fill(150)
        if (eventCountsByRow[row] !== undefined) {
          if (row == 0) text("COLLISIONS", xOffset, yPos);
          else text(`+ ${nf(eventCountsByRow[row], 3)}`, xOffset + 10, yPos);
        }
      }
    }

    function keyPressed() {
      if (key == "s") save("collisions.svg");
    }
  </script>
</body>

</html>